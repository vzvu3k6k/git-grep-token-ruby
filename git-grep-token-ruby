#!/usr/bin/env ruby

require "parser/current"
require "shellwords"

def search(node, return_when_finding: true, &block)
  node.children.each.with_object([]) do |child, result|
    next unless child.is_a?(Parser::AST::Node)
    if block.call(child)
      result << child
      next if return_when_finding
    end
    result.concat(search(child, &block))
  end
end

def extract(ast, word)
  search(ast) do |node|
    (node.type == :block && node.children[0].type == :send && node.children[0].children[1] == word) || # for passing a literal block
      (node.children.any?{|c| c == word })
  end.map do |node|
    last_heredoc_line = search(node, return_when_finding: false){|c| (c.type == :dstr || c.type == :str)}
      .map{|node| node.loc.expression.end.line}.max

    start = node.loc.expression.begin.line
    finish = [(last_heredoc_line || 0), node.loc.expression.end.line].max
    [start, finish]
  end
end

if $0 == __FILE__
  word = ARGV.shift.to_sym
  opts = ARGV

  cmd = "git grep --name-only #{Shellwords.escape(word)} #{[opts].flatten.compact.map{|a| Shellwords.escape(a)}.join(" ")}"
  `#{cmd}`.each_line do |file|
    file.strip!
    code = File.read(file)
    ast = Parser::CurrentRuby.parse(code)

    if ast.type != :begin
      ast = AST::Node.new(:begin, [ast])
    end

    code_lines = code.each_line.to_a
    extract(ast, word).each do |(start, finish)|
      puts "#{file}:#{start}"

      snippet = code_lines[(start - 1) .. (finish - 1)].map.with_index do |line, idx|
        "#{"%6d" % [start + idx]}  #{line.gsub(word.to_s){"\x1b[01;31m#{word}\x1b[0m"}}"
      end.to_a.join
      puts snippet
    end
  end
end
